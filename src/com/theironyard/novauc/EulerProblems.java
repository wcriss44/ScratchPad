package com.theironyard.novauc;

import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;

public class EulerProblems {

/********************************************************************************************
 *                                          Problem 1
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * By starting with 1 and 2, the first 10 terms will be:
 *
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 *
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
 * find the sum of the even-valued terms.
 *
 ********************************************************************************************/
    public int evenFibs(int n){
        int sum = 1;
        int sum2 = 2;
        int middleMan;
        int runningTotal = 3;
        int finalValue = 2;

        while (runningTotal < n){
            middleMan = sum2;
            sum2+=sum;
            sum = middleMan;
            runningTotal = sum2;
            if (sum2%2 == 0) {
                finalValue += sum2;
            }
        }
        return finalValue;
    }

    /********************************************************************************************
     *                                          Problem 2
     * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
     * The sum of these multiples is 23.
     *
     * Find the sum of all the multiples of 3 or 5 below 1000.
     *
     ********************************************************************************************/

    public int multiples35(int n){
        int result = 0;
        for(int i = 1; i < n; i++) {
            if (i % 3 == 0 || i % 5 == 0) {
                result += i;
            }
        }
        return result;
    }

    /********************************************************************************************
     *                                          Problem 3
     * The prime factors of 13195 are 5, 7, 13 and 29.
     *
     * What is the largest prime factor of the number 600851475143 ?
     *
     ********************************************************************************************/

    public long largesPrimeFacts(long n){
        boolean divisionTest;
        long bigCheck = 0L;
        ArrayList<Long> factors = new ArrayList<>();
        for (long i = 2; i < n; i++){
            divisionTest = false;
            if (n % i == 0){
                productCheck:for (long x = 2; x <= i; x++){
                    if (i % x == 0 && x != i){ //this is causing a bug when x and i are equal
                        divisionTest = false;
                        break productCheck;
                    }
                    if (x == i){
                        divisionTest = true;
                    }
                }
            } if (divisionTest){
                n = n/i;
                factors.add(i);
            }
        }
        factors.add(n);
        for(Long i: factors){
            if (i.longValue() > bigCheck){
                bigCheck = i.longValue();
            }
        }
        return n > bigCheck ? n:bigCheck;
    }

    /********************************************************************************************
     *                                          Problem 4
     * A palindromic number reads the same both ways.
     * The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
     *
     * Find the largest palindrome made from the product of two 3-digit numbers.
     *
     ********************************************************************************************/

    public int pallyNumb(int firstMax, int secondMax){
        ArrayList<Integer> numberStorage = new ArrayList<>();
        for (int x = firstMax; x > 0; x--){
            for (int y = secondMax; y > 0; y--){
                String check = String.format("%s",x*y);
                StringBuilder checkerString = new StringBuilder(check);
                int back = Integer.valueOf(checkerString.reverse().toString());
                int front = x*y;
                if(front == back){
                    numberStorage.add(front);
                }
            }
        }
        int ans = 1;
        for(Integer i : numberStorage){
            if (i > ans){
                ans = i;
            }
        }
        return ans;
    }

    /********************************************************************************************
     *                                          Problem 5
     * The Fibonacci sequence is defined by the recurrence relation:
     * Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
     * Hence the first 12 terms will be:
     * F1 = 1
     * F2 = 1
     * F3 = 2
     * F4 = 3
     * F5 = 5
     * F6 = 8
     * F7 = 13
     * F8 = 21
     * F9 = 34
     * F10 = 55
     * F11 = 89
     * F12 = 144
     * The 12th term, F12, is the first term to contain three digits.
     *
     * What is the index of the first term in the Fibonacci sequence to contain 1000 digits?
     *
     ********************************************************************************************/

    public int fibIndex(int n){
        BigInteger firstNum = BigInteger.ZERO;
        BigInteger secondNum = BigInteger.ONE;
        BigInteger fib = BigInteger.valueOf(2);
        BigInteger middleMan;
        BigInteger i = BigInteger.valueOf(3);
        BigInteger bigN = BigInteger.TEN;
        BigInteger looper = BigInteger.TEN;
        while (n > 0){
            bigN = bigN.multiply(looper);
            n--;
        }
        while (fib.compareTo(bigN) == -1){
            i = i.add(BigInteger.ONE);
            middleMan = secondNum;
            secondNum = secondNum.add(firstNum);
            firstNum = middleMan;

            fib = fib.add(secondNum);
        }
        return i.intValue();
    }

    /********************************************************************************************
     *                                          Problem 6
     * 2520 is the smallest number that can be divided by each of the numbers
     * from 1 to 10 without any remainder.
     *
     * What is the smallest positive number that is evenly divisible by all
     * of the numbers from 1 to 20?
     *
     ********************************************************************************************/

    public int smallestMulti(){
        int i = 20;
        while(true){
            i++;
            if (i%20 == 0 && i%19 == 0 && i%18 == 0&& i%17 == 0 && i%16 == 0 && i%15 == 0 && i%14 == 0 && i%13 == 0 && i%12 == 0 && i%11 == 0 && i%10 == 0 && i%9 == 0 && i%8 == 0&& i%7 == 0 && i%6 == 0 && i%5 == 0 && i%4 == 0 && i%3 == 0 && i%2 == 0){
                return i;


            }
        }
    }

    /********************************************************************************************
     *                                          Problem 7
     * The Fibonacci sequence is defined by the recurrence relation:
     *
     * Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
     *
     * It turns out that F541, which contains 113 digits, is the first Fibonacci number
     * for which the last nine digits are 1-9 pandigital (contain all the digits 1 to 9,
     * but not necessarily in order). And F2749, which contains 575 digits, is the first Fibonacci
     * number for which the first nine digits are 1-9 pandigital.
     *
     * Given that Fk is the first Fibonacci number for which the first nine digits AND the last
     * nine digits are 1-9 pandigital, find k.
     *
     ********************************************************************************************/

    public int fibPanChecker() {
        BigInteger fNum, sNum, fibNum;
        fNum = BigInteger.ONE;
        sNum = BigInteger.ZERO;
        int fibIndex = 1;
        boolean checker = false, theEnd = false;

        something: while(true){

            fibNum = fNum.add(sNum);

            fibIndex++;
            System.out.println("Your index: " + fibIndex);
            //System.out.println("\tYour number: " +fibNum.toString());
            BigInteger endChecker = BigInteger.valueOf(1000000000);


            int end = (fibNum.mod(endChecker)).intValue();
            String back = String.valueOf(end);
            if (fibNum.toString().length() < 19){
            } else {

                for (int x = 1; x <= 9; x++) {
                    if (!back.contains(String.valueOf(x))) {
                        break;
                    }
                    if (x == 9) {
                        theEnd = true;
                    }
                }
                if (theEnd) {
                    String front = fibNum.toString().substring(0, 9);
                    for (int x = 1; x <= 9; x++) {
                        if (!(front.contains(String.valueOf(x)))) {
                            theEnd = false;
                            break;
                        }
                        if (x == 9){
                            checker = true;
                        }
                    }
                    if (checker) {
                        return fibIndex;
                    }
                }
            }
            sNum = fNum;
            fNum = fibNum;
        }
    }
}
